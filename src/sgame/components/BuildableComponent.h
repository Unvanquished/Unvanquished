#ifndef BUILDABLE_COMPONENT_H_
#define BUILDABLE_COMPONENT_H_

#include "../backend/CBSEBackend.h"
#include "../backend/CBSEComponents.h"

class BuildableComponent: public BuildableComponentBase {
	public:
		enum lifecycle_t {
			// Alive states.
			CONSTRUCTING,
			CONSTRUCTED,
			// Dead states.
			PRE_BLAST,
			POST_BLAST
		};

		// ///////////////////// //
		// Autogenerated Members //
		// ///////////////////// //

		/**
		 * @brief Default constructor of the BuildableComponent.
		 * @param entity The entity that owns the component instance.
		 * @param r_HealthComponent A HealthComponent instance that this component depends on.
		 * @param r_ThinkingComponent A ThinkingComponent instance that this component depends on.
		 * @param r_TeamComponent A TeamComponent instance that this component depends on.
		 * @note This method is an interface for autogenerated code, do not modify its signature.
		 */
		BuildableComponent(Entity& entity, HealthComponent& r_HealthComponent, ThinkingComponent& r_ThinkingComponent, TeamComponent& r_TeamComponent);

		/**
		 * @brief Handle the PrepareNetCode message.
		 * @note This method is an interface for autogenerated code, do not modify its signature.
		 */
		void HandlePrepareNetCode();

		/**
		 * @brief Handle the Die message.
		 * @param killer
		 * @param meansOfDeath
		 * @note This method is an interface for autogenerated code, do not modify its signature.
		 */
		void HandleDie(gentity_t* killer, meansOfDeath_t meansOfDeath);

		// ///////////////////// //

		void Think(int timeDelta);

		lifecycle_t GetState() { return state; }
		void SetState(lifecycle_t state) { this->state = state; }

		/**
		 * @return Whether the buildable is currently marked for deconstruction.
		 */
		bool MarkedForDeconstruction() const { return marked; }

		/**
		 * @return Time when the buildable was marked for deconstruction or 0 if it isn't currently marked.
		 */
		int  GetMarkTime() const { return marked ? markTime : 0; }

		void SetDeconstructionMark() { marked = true; markTime = level.time(); }
		void ClearDeconstructionMark() { marked = false; }
		void ToggleDeconstructionMark() { marked = !marked; if (marked) markTime = level.time(); }

		/**
		 * @brief Change the buildable's power state.
		 */
		void SetPowerState(bool powered);

		/**
		 * @return Whether the buildable is or will be powered.
		 * @todo Make entity.oldEnt->powered a component member.
		 */
		bool Powered() const { return entity.oldEnt->powered; }

		/**
		 * @return Whether the buildable has completed construction and is alive and powered.
		 */
		bool Active() const { return state == CONSTRUCTED && Powered(); }

		void SetAimAngles(const Vec3 aimAngles) { this->aimAngles = aimAngles; }
		Vec3 AimAngles() const { return this->aimAngles; }

		/**
		 * Protect current animation from being disrupted by selected, less important animations.
		 * A value of 0 protects for the rest of the frame only.
		 */
		void ProtectAnimation(int duration) { protectAnimationUntil = level.time() + duration; }
		void UnprotectAnimation() { protectAnimationUntil = -1; }

		/**
		 * While the current animation is protected, less important animations should not be played.
		 */
		bool AnimationProtected() const { return (protectAnimationUntil > level.time()); }

	private:
		lifecycle_t state;

		bool constructionHasFinished;

		bool marked;
		int  markTime;

		Vec3 aimAngles; /**< Aim angles relative to world. */

		int protectAnimationUntil;

		// TODO: Move gentity_t.deconstruct and gentity_t.powered here.
		//bool powered;
};

#endif // BUILDABLE_COMPONENT_H_
